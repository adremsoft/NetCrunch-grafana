{"version":3,"sources":["../../../../../src/datasource/services/netCrunchAPI/netCrunchConnection/trendData.js"],"names":["asArray","data","Array","isArray","NetCrunchTrendData","netCrunchConnection","convertPeriodTypeToName","periodType","PERIOD_NAMES","calculateMaxDataPoints","maxDataPoints","result","MAX_SAMPLE_COUNT","DEFAULT","maxDataPointsInt","parseInt","isNaN","MIN","MAX","floorTime","time","period","minuteRemains","toUpperCase","minute","subtract","startOf","addMarginsToTimeRange","rangeFrom","rangeTo","moment","periodInterval","periodName","add","from","to","calculateRAWTimeRange","PERIOD_TYPE","tpMinutes","calculateChartDataInterval","dateStart","dateEnd","maxSampleCount","min","hour","day","month","periods","length","type","interval","tpHours","tpDays","tpMonths","periodIndex","some","index","calculateTimeRange","prepareResultMask","series","resultMask","Object","keys","filter","seriesKey","map","QUERY_RESULT_MASKS","ResultMask","calculateTimeDomain","dateFrom","intervalCount","timeDomain","timeDomainItem","i","push","toDate","convertResultData","resultType","convertedData","create","resultSeries","QUERY_RESULT_ORDER","indexOf","seriesType","forEach","seriesName","trend","value","$index","distr","getCounterTrendData","nodeID","counter","dateTo","Promise","resolve","avg","queryTrendData","toString","then","domain","values","NETCRUNCH_TREND_DATA_CONST","RAW_DATA_MAX_RANGE","prepareTimeRange","rawData","range","error","getCounterTrendRAWData","getCounterData","counterName","grafanaDataConverter","getTime","max","avail","delta","equal"],"mappings":"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","file":"trendData.js","sourcesContent":["/**\r\n * @license\r\n * Copyright AdRem Software. All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an Apache License, Version 2.0 that can be\r\n * found in the LICENSE file.\r\n */\r\n\r\n/* eslint-disable no-param-reassign */\r\n\r\nimport moment from 'moment';\r\n\r\nconst NETCRUNCH_TREND_DATA_CONST = {\r\n\r\n  MAX_SAMPLE_COUNT: {\r\n    MIN: 10,\r\n    DEFAULT: 200,\r\n    MAX: 5000,\r\n  },\r\n\r\n  PERIOD_TYPE: {\r\n    tpMinutes: 0,\r\n    tpHours: 1,\r\n    tpDays: 2,\r\n    tpMonths: 3,\r\n  },\r\n\r\n  QUERY_RESULT_MASKS: {\r\n    min: 'tqrMin',\r\n    avg: 'tqrAvg',\r\n    max: 'tqrMax',\r\n    avail: 'tqrAvail',\r\n    delta: 'tqrDelta',\r\n    equal: 'tqrEqual',\r\n    distr: 'tqrDistr',\r\n  },\r\n\r\n  QUERY_RESULT_ORDER: ['avg', 'min', 'max', 'avail', 'delta', 'equal'],\r\n};\r\n\r\nfunction asArray(data) {\r\n  return Array.isArray(data) ? data : [data];\r\n}\r\n\r\nfunction NetCrunchTrendData(netCrunchConnection) {\r\n  const\r\n    PERIOD_TYPE = NETCRUNCH_TREND_DATA_CONST.PERIOD_TYPE,\r\n    PERIOD_NAMES = {\r\n      [PERIOD_TYPE.tpMinutes]: 'minutes',\r\n      [PERIOD_TYPE.tpHours]: 'hours',\r\n      [PERIOD_TYPE.tpDays]: 'days',\r\n      [PERIOD_TYPE.tpMonths]: 'months',\r\n    },\r\n    QUERY_RESULT_MASKS = NETCRUNCH_TREND_DATA_CONST.QUERY_RESULT_MASKS,\r\n    QUERY_RESULT_ORDER = NETCRUNCH_TREND_DATA_CONST.QUERY_RESULT_ORDER,\r\n    MAX_SAMPLE_COUNT = NETCRUNCH_TREND_DATA_CONST.MAX_SAMPLE_COUNT,\r\n    RAW_DATA_MAX_RANGE = {\r\n      periodInterval: 2,\r\n      periodName: PERIOD_NAMES[PERIOD_TYPE.tpDays],\r\n    };\r\n\r\n  function convertPeriodTypeToName(periodType) {\r\n    return PERIOD_NAMES[periodType];\r\n  }\r\n\r\n  function calculateMaxDataPoints(maxDataPoints = null) {\r\n    let result = MAX_SAMPLE_COUNT.DEFAULT;\r\n\r\n    if (maxDataPoints != null) {\r\n      const maxDataPointsInt = parseInt(maxDataPoints, 10);\r\n      if ((!isNaN(maxDataPoints)) &&\r\n        (maxDataPoints >= MAX_SAMPLE_COUNT.MIN) && (maxDataPoints <= MAX_SAMPLE_COUNT.MAX)) {\r\n        result = maxDataPointsInt;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  function floorTime(time, period) {                // period: minutes, hours, days, months\r\n    const MINUTES_SLOT = 5;\r\n    let\r\n      minuteRemains,\r\n      result;\r\n\r\n    period = period.toUpperCase();\r\n    if (period === 'MINUTES') {\r\n      minuteRemains = time.minute() % MINUTES_SLOT;\r\n      result = time.subtract(minuteRemains, 'minutes');\r\n    } else {\r\n      if (period === 'HOURS') {\r\n        period = 'hour';\r\n      } else if (period === 'DAYS') {\r\n        period = 'day';\r\n      } else if (period === 'MONTHS') {\r\n        period = 'month';\r\n      }\r\n      result = time.startOf(period);\r\n    }\r\n    return result.startOf('minute');\r\n  }\r\n\r\n  function addMarginsToTimeRange(rangeFrom, rangeTo, period) {\r\n\r\n    rangeFrom = moment(rangeFrom).subtract(period.periodInterval, period.periodName);\r\n    rangeTo = moment(rangeTo).add(period.periodInterval, period.periodName);\r\n\r\n    if (rangeTo > moment()) {\r\n      rangeTo = moment();\r\n    }\r\n\r\n    return {\r\n      from: floorTime(rangeFrom, period.periodName),\r\n      to: rangeTo,\r\n      periodInterval: period.periodInterval,\r\n      periodType: period.periodType,\r\n      periodName: period.periodName,\r\n    };\r\n  }\r\n\r\n  function calculateRAWTimeRange(rangeFrom, rangeTo) {\r\n    const period = {\r\n      periodType: PERIOD_TYPE.tpMinutes,\r\n      periodName: convertPeriodTypeToName(PERIOD_TYPE.tpMinutes),\r\n      periodInterval: 1,\r\n    };\r\n    return addMarginsToTimeRange(rangeFrom, rangeTo, period);\r\n  }\r\n\r\n  function calculateChartDataInterval(dateStart, dateEnd, maxSampleCount) {\r\n    const\r\n      min = 60 * 1000,\r\n      hour = 60 * min,\r\n      day = 24 * hour,\r\n      month = 30 * day,\r\n      dateRange = Number(dateEnd - dateStart),\r\n\r\n      periods = [\r\n        { length: min, type: PERIOD_TYPE.tpMinutes, interval: 1 },\r\n        { length: 5 * min, type: PERIOD_TYPE.tpMinutes, interval: 5 },\r\n        { length: 10 * min, type: PERIOD_TYPE.tpMinutes, interval: 10 },\r\n        { length: 15 * min, type: PERIOD_TYPE.tpMinutes, interval: 15 },\r\n        { length: 20 * min, type: PERIOD_TYPE.tpMinutes, interval: 20 },\r\n        { length: 30 * min, type: PERIOD_TYPE.tpMinutes, interval: 30 },\r\n        { length: hour, type: PERIOD_TYPE.tpHours, interval: 1 },\r\n        { length: 2 * hour, type: PERIOD_TYPE.tpHours, interval: 2 },\r\n        { length: 3 * hour, type: PERIOD_TYPE.tpHours, interval: 3 },\r\n        { length: 4 * hour, type: PERIOD_TYPE.tpHours, interval: 4 },\r\n        { length: 6 * hour, type: PERIOD_TYPE.tpHours, interval: 6 },\r\n        { length: 8 * hour, type: PERIOD_TYPE.tpHours, interval: 8 },\r\n        { length: day, type: PERIOD_TYPE.tpDays, interval: 1 },\r\n        { length: 7 * day, type: PERIOD_TYPE.tpDays, interval: 7 },\r\n        { length: month, type: PERIOD_TYPE.tpMonths, interval: 1 },\r\n        { length: 3 * month, type: PERIOD_TYPE.tpMonths, interval: 3 },\r\n        { length: 6 * month, type: PERIOD_TYPE.tpMonths, interval: 6 },\r\n        { length: 9 * month, type: PERIOD_TYPE.tpMonths, interval: 9 },\r\n        { length: 12 * month, type: PERIOD_TYPE.tpMonths, interval: 12 },\r\n        { length: 15 * month, type: PERIOD_TYPE.tpMonths, interval: 15 },\r\n        { length: 18 * month, type: PERIOD_TYPE.tpMonths, interval: 18 },\r\n        { length: 21 * month, type: PERIOD_TYPE.tpMonths, interval: 21 },\r\n        { length: 24 * month, type: PERIOD_TYPE.tpMonths, interval: 24 },\r\n      ];\r\n\r\n    let periodIndex = 0;\r\n\r\n    periods.some((period, index) => {\r\n      if ((period.length * maxSampleCount) > dateRange) {\r\n        periodIndex = index;\r\n        return true;\r\n      }\r\n      return false;\r\n    });\r\n\r\n    return {\r\n      periodType: periods[periodIndex].type,\r\n      periodName: convertPeriodTypeToName(periods[periodIndex].type),\r\n      periodInterval: periods[periodIndex].interval,\r\n    };\r\n  }\r\n\r\n  function calculateTimeRange(rangeFrom, rangeTo, maxDataPoints) {\r\n    const period = calculateChartDataInterval(rangeFrom, rangeTo, maxDataPoints);\r\n    return addMarginsToTimeRange(rangeFrom, rangeTo, period);\r\n  }\r\n\r\n  function prepareResultMask(series) {\r\n    let resultMask;\r\n\r\n    resultMask = Object.keys(series).filter(seriesKey =>\r\n      ((series[seriesKey] === true) && (QUERY_RESULT_MASKS[seriesKey] != null)));\r\n\r\n    resultMask = resultMask.map(seriesKey => QUERY_RESULT_MASKS[seriesKey]);\r\n\r\n    return { ResultMask: resultMask };\r\n  }\r\n\r\n  function calculateTimeDomain(dateFrom, periodType, periodInterval, intervalCount) {\r\n    const\r\n      timeDomain = [],\r\n      periodName = convertPeriodTypeToName(periodType);\r\n    let\r\n      timeDomainItem,\r\n      i;\r\n\r\n    dateFrom = moment(dateFrom).startOf('minute');\r\n    for (i = 0; i < intervalCount; i += 1) {\r\n      timeDomainItem = moment(dateFrom).add(i * periodInterval, periodName);\r\n      timeDomain.push(timeDomainItem.toDate());\r\n    }\r\n    return timeDomain;\r\n  }\r\n\r\n  function convertResultData(result, resultType) {\r\n    const convertedData = Object.create(null);\r\n    let resultSeries;\r\n\r\n    resultType = resultType.ResultMask;\r\n    // eslint-disable-next-line\r\n    resultSeries = QUERY_RESULT_ORDER.filter(seriesType => (resultType.indexOf(QUERY_RESULT_MASKS[seriesType]) >= 0));\r\n    resultSeries.forEach((seriesName) => {\r\n      convertedData[seriesName] = [];\r\n    });\r\n\r\n    result.trend.forEach((data) => {\r\n      asArray(data).forEach((value, $index) => {\r\n        convertedData[resultSeries[$index]].push(value);\r\n      });\r\n    });\r\n\r\n    if (result.distr != null) {\r\n      convertedData.distr = result.distr;\r\n    }\r\n\r\n    return convertedData;\r\n  }\r\n\r\n  function prepareTimeRange(rangeFrom, rangeTo, rawData, maxDataPoints = null) {\r\n    let range = null;\r\n\r\n    maxDataPoints = calculateMaxDataPoints(maxDataPoints);\r\n    if (rawData === true) {\r\n      if (moment(rangeTo).subtract(RAW_DATA_MAX_RANGE.periodInterval, RAW_DATA_MAX_RANGE.periodName) <= rangeFrom) {\r\n        range = {\r\n          result: calculateRAWTimeRange(rangeFrom, rangeTo),\r\n        };\r\n      } else {\r\n        range = {\r\n          error: {\r\n            periodInterval: RAW_DATA_MAX_RANGE.periodInterval,\r\n            periodName: RAW_DATA_MAX_RANGE.periodName,\r\n          },\r\n        };\r\n      }\r\n    } else {\r\n      range = {\r\n        result: calculateTimeRange(rangeFrom, rangeTo, maxDataPoints),\r\n      };\r\n    }\r\n\r\n    return range;\r\n  }\r\n\r\n  function getCounterTrendData(nodeID, counter, dateFrom, dateTo, periodType = PERIOD_TYPE.tpHours,\r\n                               periodInterval = 1, resultType = null) {      // eslint-disable-line\r\n\r\n    // resultType possible values are:\r\n    //    [ tqrAvg, tqrMin, tqrMax, tqrAvail, tqrDelta, tqrEqual, tqrDistr ]\r\n    // Default tqrAvg is used : {ResultMask : ['tqrAvg']}\r\n\r\n    if ((nodeID == null) || (counter == null)) {\r\n      return Promise.resolve(null);\r\n    }\r\n\r\n    resultType = (resultType == null) ? prepareResultMask({ avg: true }) : prepareResultMask(resultType);\r\n    if (resultType.ResultMask.length === 0) {\r\n      resultType = prepareResultMask({ avg: true });\r\n    }\r\n\r\n    return netCrunchConnection\r\n      .queryTrendData(nodeID.toString(), counter, periodType, periodInterval,\r\n                      dateFrom, dateTo,\r\n                      resultType,\r\n                      null, // day mask just no mask\r\n                      null, // value for equal checking\r\n                      null)\r\n      .then((data) => {       // eslint-disable-line\r\n        return {\r\n          domain: calculateTimeDomain(dateFrom, periodType, periodInterval, data.trend.length),\r\n          values: convertResultData(data, resultType),\r\n        };\r\n      });\r\n  }\r\n\r\n  function getCounterTrendRAWData(nodeID, counter, dateFrom, dateTo, resultType) {\r\n    return getCounterTrendData(nodeID, counter, dateFrom, dateTo, PERIOD_TYPE.tpMinutes, 1, resultType);\r\n  }\r\n\r\n  function getCounterData(nodeID, counterName, dateStart, dateEnd, maxSampleCount, resultType, period) {\r\n    const result = Object.create(null);\r\n\r\n    dateEnd = dateEnd || moment();\r\n    maxSampleCount = maxSampleCount || MAX_SAMPLE_COUNT.DEFAULT;\r\n    period = period || calculateChartDataInterval(dateStart, dateEnd, maxSampleCount);\r\n\r\n    result.period = period;\r\n    result.data = getCounterTrendData(nodeID, counterName, dateStart, dateEnd, period.periodType,  period.periodInterval, resultType);\r\n    return result;\r\n  }\r\n\r\n  function grafanaDataConverter(data) {\r\n    return data.domain.map((time, $index) => [data.values[$index], time.getTime()]);\r\n  }\r\n\r\n  return {\r\n    MAX_SAMPLE_COUNT,\r\n    prepareTimeRange,\r\n    getCounterTrendData,\r\n    getCounterTrendRAWData,\r\n    getCounterData,\r\n    grafanaDataConverter,\r\n  };\r\n}\r\n\r\nexport {\r\n  NETCRUNCH_TREND_DATA_CONST,\r\n  NetCrunchTrendData,\r\n};\r\n"]}